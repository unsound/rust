/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const MYSQL_SERVER_VERSION: &'static [u8; 7usize] = b"5.7.11\x00";
pub const MYSQL_BASE_VERSION: &'static [u8; 11usize] = b"mysqld-5.7\x00";
pub const MYSQL_SERVER_SUFFIX_DEF: &'static [u8; 1usize] = b"\x00";
pub const MYSQL_VERSION_ID: ::std::os::raw::c_uint = 50711;
pub const MYSQL_PORT: ::std::os::raw::c_uint = 3306;
pub const MYSQL_PORT_DEFAULT: ::std::os::raw::c_uint = 0;
pub const MYSQL_UNIX_ADDR: &'static [u8; 16usize] = b"/tmp/mysql.sock\x00";
pub const MYSQL_CONFIG_NAME: &'static [u8; 3usize] = b"my\x00";
pub const MYSQL_COMPILATION_COMMENT: &'static [u8; 9usize] = b"Homebrew\x00";
pub const MYSQL_AUTODETECT_CHARSET_NAME: &'static [u8; 5usize] = b"auto\x00";
pub const MYSQL_ERRMSG_SIZE: ::std::os::raw::c_uint = 512;
pub const MYSQL_STMT_HEADER: ::std::os::raw::c_uint = 4;
pub const MYSQL_LONG_DATA_HEADER: ::std::os::raw::c_uint = 6;
pub const MYSQL_CLIENT_reserved1: ::std::os::raw::c_uint = 0;
pub const MYSQL_CLIENT_reserved2: ::std::os::raw::c_uint = 1;
pub const MYSQL_CLIENT_AUTHENTICATION_PLUGIN: ::std::os::raw::c_uint = 2;
pub const MYSQL_CLIENT_TRACE_PLUGIN: ::std::os::raw::c_uint = 3;
pub const MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION: ::std::os::raw::c_uint = 256;
pub const MYSQL_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION: ::std::os::raw::c_uint = 256;
pub const MYSQL_CLIENT_MAX_PLUGINS: ::std::os::raw::c_uint = 4;
pub const MYSQL_USERNAME_LENGTH: ::std::os::raw::c_uint = 96;
pub const MYSQL_NO_DATA: ::std::os::raw::c_uint = 100;
pub const MYSQL_DATA_TRUNCATED: ::std::os::raw::c_uint = 101;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type my_bool = ::std::os::raw::c_char;
pub type my_socket = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_field_types {
    MYSQL_TYPE_DECIMAL = 0,
    MYSQL_TYPE_TINY = 1,
    MYSQL_TYPE_SHORT = 2,
    MYSQL_TYPE_LONG = 3,
    MYSQL_TYPE_FLOAT = 4,
    MYSQL_TYPE_DOUBLE = 5,
    MYSQL_TYPE_NULL = 6,
    MYSQL_TYPE_TIMESTAMP = 7,
    MYSQL_TYPE_LONGLONG = 8,
    MYSQL_TYPE_INT24 = 9,
    MYSQL_TYPE_DATE = 10,
    MYSQL_TYPE_TIME = 11,
    MYSQL_TYPE_DATETIME = 12,
    MYSQL_TYPE_YEAR = 13,
    MYSQL_TYPE_NEWDATE = 14,
    MYSQL_TYPE_VARCHAR = 15,
    MYSQL_TYPE_BIT = 16,
    MYSQL_TYPE_TIMESTAMP2 = 17,
    MYSQL_TYPE_DATETIME2 = 18,
    MYSQL_TYPE_TIME2 = 19,
    MYSQL_TYPE_JSON = 245,
    MYSQL_TYPE_NEWDECIMAL = 246,
    MYSQL_TYPE_ENUM = 247,
    MYSQL_TYPE_SET = 248,
    MYSQL_TYPE_TINY_BLOB = 249,
    MYSQL_TYPE_MEDIUM_BLOB = 250,
    MYSQL_TYPE_LONG_BLOB = 251,
    MYSQL_TYPE_BLOB = 252,
    MYSQL_TYPE_VAR_STRING = 253,
    MYSQL_TYPE_STRING = 254,
    MYSQL_TYPE_GEOMETRY = 255,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_vio([u8; 0]);
pub type Vio = st_vio;
#[repr(C)]
pub struct st_net {
    pub vio: *mut Vio,
    pub buff: *mut ::std::os::raw::c_uchar,
    pub buff_end: *mut ::std::os::raw::c_uchar,
    pub write_pos: *mut ::std::os::raw::c_uchar,
    pub read_pos: *mut ::std::os::raw::c_uchar,
    pub fd: my_socket,
    pub remain_in_buf: ::std::os::raw::c_ulong,
    pub length: ::std::os::raw::c_ulong,
    pub buf_length: ::std::os::raw::c_ulong,
    pub where_b: ::std::os::raw::c_ulong,
    pub max_packet: ::std::os::raw::c_ulong,
    pub max_packet_size: ::std::os::raw::c_ulong,
    pub pkt_nr: ::std::os::raw::c_uint,
    pub compress_pkt_nr: ::std::os::raw::c_uint,
    pub write_timeout: ::std::os::raw::c_uint,
    pub read_timeout: ::std::os::raw::c_uint,
    pub retry_count: ::std::os::raw::c_uint,
    pub fcntl: ::std::os::raw::c_int,
    pub return_status: *mut ::std::os::raw::c_uint,
    pub reading_or_writing: ::std::os::raw::c_uchar,
    pub save_char: ::std::os::raw::c_char,
    pub unused1: my_bool,
    pub unused2: my_bool,
    pub compress: my_bool,
    pub unused3: my_bool,
    pub unused: *mut ::std::os::raw::c_uchar,
    pub last_errno: ::std::os::raw::c_uint,
    pub error: ::std::os::raw::c_uchar,
    pub unused4: my_bool,
    pub unused5: my_bool,
    /** Client library error message buffer. Actually belongs to struct MYSQL. */
    pub last_error: [::std::os::raw::c_char; 512usize],
    /** Client library sqlstate buffer. Set along with the error message. */
    pub sqlstate: [::std::os::raw::c_char; 6usize],
    /**
    Extension pointer, for the caller private use.
    Any program linking with the networking library can use this pointer,
    which is handy when private connection specific data needs to be
    maintained.
    The mysqld server process uses this pointer internally,
    to maintain the server internal instrumentation for the connection.
  */
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_net() {
    assert_eq!(::std::mem::size_of::<st_net>(), 680usize);
    assert_eq!(::std::mem::align_of::<st_net>(), 8usize);
}
pub type NET = st_net;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_enum_shutdown_level {
    SHUTDOWN_DEFAULT = 0,
    SHUTDOWN_WAIT_CONNECTIONS = 1,
    SHUTDOWN_WAIT_TRANSACTIONS = 2,
    SHUTDOWN_WAIT_UPDATES = 8,
    SHUTDOWN_WAIT_ALL_BUFFERS = 16,
    SHUTDOWN_WAIT_CRITICAL_BUFFERS = 17,
    KILL_QUERY = 254,
    KILL_CONNECTION = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_mysql_set_option {
    MYSQL_OPTION_MULTI_STATEMENTS_ON = 0,
    MYSQL_OPTION_MULTI_STATEMENTS_OFF = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_session_state_type {
    SESSION_TRACK_SYSTEM_VARIABLES = 0,
    SESSION_TRACK_SCHEMA = 1,
    SESSION_TRACK_STATE_CHANGE = 2,
    SESSION_TRACK_GTIDS = 3,
    SESSION_TRACK_TRANSACTION_CHARACTERISTICS = 4,
    SESSION_TRACK_TRANSACTION_STATE = 5,
}
extern "C" {
    pub fn mysql_errno_to_sqlstate(mysql_errno: ::std::os::raw::c_uint)
                                   -> *const ::std::os::raw::c_char;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_mysql_timestamp_type {
    MYSQL_TIMESTAMP_NONE = -2,
    MYSQL_TIMESTAMP_ERROR = -1,
    MYSQL_TIMESTAMP_DATE = 0,
    MYSQL_TIMESTAMP_DATETIME = 1,
    MYSQL_TIMESTAMP_TIME = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_time {
    pub year: ::std::os::raw::c_uint,
    pub month: ::std::os::raw::c_uint,
    pub day: ::std::os::raw::c_uint,
    pub hour: ::std::os::raw::c_uint,
    pub minute: ::std::os::raw::c_uint,
    pub second: ::std::os::raw::c_uint,
    /**< microseconds */
    pub second_part: ::std::os::raw::c_ulong,
    pub neg: my_bool,
    pub time_type: enum_mysql_timestamp_type,
}
#[test]
fn bindgen_test_layout_st_mysql_time() {
    assert_eq!(::std::mem::size_of::<st_mysql_time>(), 40usize);
    assert_eq!(::std::mem::align_of::<st_mysql_time>(), 8usize);
}
impl Clone for st_mysql_time {
    fn clone(&self) -> Self {
        *self
    }
}
pub type MYSQL_TIME = st_mysql_time;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_list {
    pub prev: *mut st_list,
    pub next: *mut st_list,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_list() {
    assert_eq!(::std::mem::size_of::<st_list>(), 24usize);
    assert_eq!(::std::mem::align_of::<st_list>(), 8usize);
}
impl Clone for st_list {
    fn clone(&self) -> Self {
        *self
    }
}
pub type LIST = st_list;
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_client_plugin {
    pub type_: ::std::os::raw::c_int,
    pub interface_version: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub author: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub version: [::std::os::raw::c_uint; 3usize],
    pub license: *const ::std::os::raw::c_char,
    pub mysql_api: *mut ::std::os::raw::c_void,
    pub init: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char,
                                                         arg2: usize,
                                                         arg3: ::std::os::raw::c_int,
                                                         arg4: *mut __va_list_tag)
                                                         -> ::std::os::raw::c_int>,
    pub deinit: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub options: ::std::option::Option<unsafe extern "C" fn(option: *const ::std::os::raw::c_char,
                                                            arg1: *const ::std::os::raw::c_void)
                                                            -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_st_mysql_client_plugin() {
    assert_eq!(::std::mem::size_of::<st_mysql_client_plugin>(), 88usize);
    assert_eq!(::std::mem::align_of::<st_mysql_client_plugin>(), 8usize);
}
impl Clone for st_mysql_client_plugin {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct st_mysql {
    pub net: NET,
    pub connector_fd: *mut ::std::os::raw::c_uchar,
    pub host: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub passwd: *mut ::std::os::raw::c_char,
    pub unix_socket: *mut ::std::os::raw::c_char,
    pub server_version: *mut ::std::os::raw::c_char,
    pub host_info: *mut ::std::os::raw::c_char,
    pub info: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub charset: *mut st_mysql_charset_info_st,
    pub fields: *mut MYSQL_FIELD,
    pub field_alloc: MEM_ROOT,
    pub affected_rows: my_ulonglong,
    pub insert_id: my_ulonglong,
    pub extra_info: my_ulonglong,
    pub thread_id: ::std::os::raw::c_ulong,
    pub packet_length: ::std::os::raw::c_ulong,
    pub port: ::std::os::raw::c_uint,
    pub client_flag: ::std::os::raw::c_ulong,
    pub server_capabilities: ::std::os::raw::c_ulong,
    pub protocol_version: ::std::os::raw::c_uint,
    pub field_count: ::std::os::raw::c_uint,
    pub server_status: ::std::os::raw::c_uint,
    pub server_language: ::std::os::raw::c_uint,
    pub warning_count: ::std::os::raw::c_uint,
    pub options: st_mysql_options,
    pub status: mysql_status,
    pub free_me: my_bool,
    pub reconnect: my_bool,
    pub scramble: [::std::os::raw::c_char; 21usize],
    pub unused1: my_bool,
    pub unused2: *mut ::std::os::raw::c_void,
    pub unused3: *mut ::std::os::raw::c_void,
    pub unused4: *mut ::std::os::raw::c_void,
    pub unused5: *mut ::std::os::raw::c_void,
    pub stmts: *mut LIST,
    pub methods: *const st_mysql_methods,
    pub thd: *mut ::std::os::raw::c_void,
    pub unbuffered_fetch_owner: *mut my_bool,
    pub info_buffer: *mut ::std::os::raw::c_char,
    pub extension: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_charset_info_st([u8; 0]);
#[test]
fn bindgen_test_layout_st_mysql() {
    assert_eq!(::std::mem::size_of::<st_mysql>(), 1304usize);
    assert_eq!(::std::mem::align_of::<st_mysql>(), 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_plugin_vio_info {
    pub protocol: st_plugin_vio_info__bindgen_ty_1,
    /**< it's set, if the protocol is SOCKET or TCP */
    pub socket: ::std::os::raw::c_int,
}
pub const st_plugin_vio_info_MYSQL_VIO_INVALID: st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_INVALID;
pub const st_plugin_vio_info_MYSQL_VIO_TCP: st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_TCP;
pub const st_plugin_vio_info_MYSQL_VIO_SOCKET: st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_SOCKET;
pub const st_plugin_vio_info_MYSQL_VIO_PIPE: st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_PIPE;
pub const st_plugin_vio_info_MYSQL_VIO_MEMORY: st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_MEMORY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum st_plugin_vio_info__bindgen_ty_1 {
    MYSQL_VIO_INVALID = 0,
    MYSQL_VIO_TCP = 1,
    MYSQL_VIO_SOCKET = 2,
    MYSQL_VIO_PIPE = 3,
    MYSQL_VIO_MEMORY = 4,
}
#[test]
fn bindgen_test_layout_st_plugin_vio_info() {
    assert_eq!(::std::mem::size_of::<st_plugin_vio_info>(), 8usize);
    assert_eq!(::std::mem::align_of::<st_plugin_vio_info>(), 4usize);
}
impl Clone for st_plugin_vio_info {
    fn clone(&self) -> Self {
        *self
    }
}
pub type MYSQL_PLUGIN_VIO_INFO = st_plugin_vio_info;
/**
  Provides plugin access to communication channel
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_plugin_vio {
    /**
    Plugin provides a pointer reference and this function sets it to the
    contents of any incoming packet. Returns the packet length, or -1 if
    the plugin should terminate.
  */
    pub read_packet:
        ::std::option::Option<unsafe extern "C" fn(vio: *mut st_plugin_vio,
                                                   buf: *mut *mut ::std::os::raw::c_uchar)
                                                   -> ::std::os::raw::c_int>,
    /**
    Plugin provides a buffer with data and the length and this
    function sends it as a packet. Returns 0 on success, 1 on failure.
  */
    pub write_packet:
        ::std::option::Option<unsafe extern "C" fn(vio: *mut st_plugin_vio,
                                                   packet: *const ::std::os::raw::c_uchar,
                                                   packet_len: ::std::os::raw::c_int)
                                                   -> ::std::os::raw::c_int>,
    /**
    Fills in a st_plugin_vio_info structure, providing the information
    about the connection.
  */
    pub info: ::std::option::Option<unsafe extern "C" fn(vio: *mut st_plugin_vio,
                                                             info: *mut st_plugin_vio_info)>,
}
#[test]
fn bindgen_test_layout_st_plugin_vio() {
    assert_eq!(::std::mem::size_of::<st_plugin_vio>(), 24usize);
    assert_eq!(::std::mem::align_of::<st_plugin_vio>(), 8usize);
}
impl Clone for st_plugin_vio {
    fn clone(&self) -> Self {
        *self
    }
}
pub type MYSQL_PLUGIN_VIO = st_plugin_vio;
extern "C" {
    /**
  loads a plugin and initializes it

  @param mysql  MYSQL structure.
  @param name   a name of the plugin to load
  @param type   type of plugin that should be loaded, -1 to disable type check
  @param argc   number of arguments to pass to the plugin initialization
                function
  @param ...    arguments for the plugin initialization function

  @retval
  a pointer to the loaded plugin, or NULL in case of a failure
*/
    pub fn mysql_load_plugin(mysql: *mut st_mysql,
                             name: *const ::std::os::raw::c_char,
                             type_: ::std::os::raw::c_int,
                             argc: ::std::os::raw::c_int,
                             ...)
                             -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  loads a plugin and initializes it, taking va_list as an argument

  This is the same as mysql_load_plugin, but take va_list instead of
  a list of arguments.

  @param mysql  MYSQL structure.
  @param name   a name of the plugin to load
  @param type   type of plugin that should be loaded, -1 to disable type check
  @param argc   number of arguments to pass to the plugin initialization
                function
  @param args   arguments for the plugin initialization function

  @retval
  a pointer to the loaded plugin, or NULL in case of a failure
*/
    pub fn mysql_load_plugin_v(mysql: *mut st_mysql,
                               name: *const ::std::os::raw::c_char,
                               type_: ::std::os::raw::c_int,
                               argc: ::std::os::raw::c_int,
                               args: *mut __va_list_tag)
                               -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  finds an already loaded plugin by name, or loads it, if necessary

  @param mysql  MYSQL structure.
  @param name   a name of the plugin to load
  @param type   type of plugin that should be loaded

  @retval
  a pointer to the plugin, or NULL in case of a failure
*/
    pub fn mysql_client_find_plugin(mysql: *mut st_mysql,
                                    name: *const ::std::os::raw::c_char,
                                    type_: ::std::os::raw::c_int)
                                    -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  adds a plugin structure to the list of loaded plugins

  This is useful if an application has the necessary functionality
  (for example, a special load data handler) statically linked into
  the application binary. It can use this function to register the plugin
  directly, avoiding the need to factor it out into a shared object.

  @param mysql  MYSQL structure. It is only used for error reporting
  @param plugin an st_mysql_client_plugin structure to register

  @retval
  a pointer to the plugin, or NULL in case of a failure
*/
    pub fn mysql_client_register_plugin(mysql: *mut st_mysql,
                                        plugin: *mut st_mysql_client_plugin)
                                        -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  set plugin options

  Can be used to set extra options and affect behavior for a plugin.
  This function may be called multiple times to set several options

  @param plugin an st_mysql_client_plugin structure
  @param option a string which specifies the option to set
  @param value  value for the option.

  @retval 0 on success, 1 in case of failure
**/
    pub fn mysql_plugin_options(plugin: *mut st_mysql_client_plugin,
                                option: *const ::std::os::raw::c_char,
                                value: *const ::std::os::raw::c_void)
                                -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_field {
    pub name: *mut ::std::os::raw::c_char,
    pub org_name: *mut ::std::os::raw::c_char,
    pub table: *mut ::std::os::raw::c_char,
    pub org_table: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub catalog: *mut ::std::os::raw::c_char,
    pub def: *mut ::std::os::raw::c_char,
    pub length: ::std::os::raw::c_ulong,
    pub max_length: ::std::os::raw::c_ulong,
    pub name_length: ::std::os::raw::c_uint,
    pub org_name_length: ::std::os::raw::c_uint,
    pub table_length: ::std::os::raw::c_uint,
    pub org_table_length: ::std::os::raw::c_uint,
    pub db_length: ::std::os::raw::c_uint,
    pub catalog_length: ::std::os::raw::c_uint,
    pub def_length: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub decimals: ::std::os::raw::c_uint,
    pub charsetnr: ::std::os::raw::c_uint,
    pub type_: enum_field_types,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_field() {
    assert_eq!(::std::mem::size_of::<st_mysql_field>(), 128usize);
    assert_eq!(::std::mem::align_of::<st_mysql_field>(), 8usize);
}
impl Clone for st_mysql_field {
    fn clone(&self) -> Self {
        *self
    }
}
pub type MYSQL_FIELD = st_mysql_field;
pub type MYSQL_ROW = *mut *mut ::std::os::raw::c_char;
pub type MYSQL_FIELD_OFFSET = ::std::os::raw::c_uint;
pub type my_ulonglong = ::std::os::raw::c_ulonglong;
/**
  Instrumented memory key.
  To instrument memory, a memory key must be obtained using @c register_memory.
  Using a zero key always disable the instrumentation.
*/
pub type PSI_memory_key = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_used_mem {
    pub next: *mut st_used_mem,
    pub left: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_st_used_mem() {
    assert_eq!(::std::mem::size_of::<st_used_mem>(), 16usize);
    assert_eq!(::std::mem::align_of::<st_used_mem>(), 8usize);
}
impl Clone for st_used_mem {
    fn clone(&self) -> Self {
        *self
    }
}
pub type USED_MEM = st_used_mem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mem_root {
    pub free: *mut USED_MEM,
    pub used: *mut USED_MEM,
    pub pre_alloc: *mut USED_MEM,
    pub min_malloc: usize,
    pub block_size: usize,
    pub block_num: ::std::os::raw::c_uint,
    pub first_block_usage: ::std::os::raw::c_uint,
    pub max_capacity: usize,
    pub allocated_size: usize,
    pub error_for_capacity_exceeded: my_bool,
    pub error_handler: ::std::option::Option<unsafe extern "C" fn()>,
    pub m_psi_key: PSI_memory_key,
}
#[test]
fn bindgen_test_layout_st_mem_root() {
    assert_eq!(::std::mem::size_of::<st_mem_root>(), 88usize);
    assert_eq!(::std::mem::align_of::<st_mem_root>(), 8usize);
}
impl Clone for st_mem_root {
    fn clone(&self) -> Self {
        *self
    }
}
pub type MEM_ROOT = st_mem_root;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_rows {
    pub next: *mut st_mysql_rows,
    pub data: MYSQL_ROW,
    pub length: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_mysql_rows() {
    assert_eq!(::std::mem::size_of::<st_mysql_rows>(), 24usize);
    assert_eq!(::std::mem::align_of::<st_mysql_rows>(), 8usize);
}
impl Clone for st_mysql_rows {
    fn clone(&self) -> Self {
        *self
    }
}
pub type MYSQL_ROWS = st_mysql_rows;
pub type MYSQL_ROW_OFFSET = *mut MYSQL_ROWS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct embedded_query_result([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_data {
    pub data: *mut MYSQL_ROWS,
    pub embedded_info: *mut embedded_query_result,
    pub alloc: MEM_ROOT,
    pub rows: my_ulonglong,
    pub fields: ::std::os::raw::c_uint,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_data() {
    assert_eq!(::std::mem::size_of::<st_mysql_data>(), 128usize);
    assert_eq!(::std::mem::align_of::<st_mysql_data>(), 8usize);
}
impl Clone for st_mysql_data {
    fn clone(&self) -> Self {
        *self
    }
}
pub type MYSQL_DATA = st_mysql_data;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_option {
    MYSQL_OPT_CONNECT_TIMEOUT = 0,
    MYSQL_OPT_COMPRESS = 1,
    MYSQL_OPT_NAMED_PIPE = 2,
    MYSQL_INIT_COMMAND = 3,
    MYSQL_READ_DEFAULT_FILE = 4,
    MYSQL_READ_DEFAULT_GROUP = 5,
    MYSQL_SET_CHARSET_DIR = 6,
    MYSQL_SET_CHARSET_NAME = 7,
    MYSQL_OPT_LOCAL_INFILE = 8,
    MYSQL_OPT_PROTOCOL = 9,
    MYSQL_SHARED_MEMORY_BASE_NAME = 10,
    MYSQL_OPT_READ_TIMEOUT = 11,
    MYSQL_OPT_WRITE_TIMEOUT = 12,
    MYSQL_OPT_USE_RESULT = 13,
    MYSQL_OPT_USE_REMOTE_CONNECTION = 14,
    MYSQL_OPT_USE_EMBEDDED_CONNECTION = 15,
    MYSQL_OPT_GUESS_CONNECTION = 16,
    MYSQL_SET_CLIENT_IP = 17,
    MYSQL_SECURE_AUTH = 18,
    MYSQL_REPORT_DATA_TRUNCATION = 19,
    MYSQL_OPT_RECONNECT = 20,
    MYSQL_OPT_SSL_VERIFY_SERVER_CERT = 21,
    MYSQL_PLUGIN_DIR = 22,
    MYSQL_DEFAULT_AUTH = 23,
    MYSQL_OPT_BIND = 24,
    MYSQL_OPT_SSL_KEY = 25,
    MYSQL_OPT_SSL_CERT = 26,
    MYSQL_OPT_SSL_CA = 27,
    MYSQL_OPT_SSL_CAPATH = 28,
    MYSQL_OPT_SSL_CIPHER = 29,
    MYSQL_OPT_SSL_CRL = 30,
    MYSQL_OPT_SSL_CRLPATH = 31,
    MYSQL_OPT_CONNECT_ATTR_RESET = 32,
    MYSQL_OPT_CONNECT_ATTR_ADD = 33,
    MYSQL_OPT_CONNECT_ATTR_DELETE = 34,
    MYSQL_SERVER_PUBLIC_KEY = 35,
    MYSQL_ENABLE_CLEARTEXT_PLUGIN = 36,
    MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS = 37,
    MYSQL_OPT_SSL_ENFORCE = 38,
    MYSQL_OPT_MAX_ALLOWED_PACKET = 39,
    MYSQL_OPT_NET_BUFFER_LENGTH = 40,
    MYSQL_OPT_TLS_VERSION = 41,
    MYSQL_OPT_SSL_MODE = 42,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_options_extention([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_options {
    pub connect_timeout: ::std::os::raw::c_uint,
    pub read_timeout: ::std::os::raw::c_uint,
    pub write_timeout: ::std::os::raw::c_uint,
    pub port: ::std::os::raw::c_uint,
    pub protocol: ::std::os::raw::c_uint,
    pub client_flag: ::std::os::raw::c_ulong,
    pub host: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub password: *mut ::std::os::raw::c_char,
    pub unix_socket: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub init_commands: *mut st_mysql_options_st_dynamic_array,
    pub my_cnf_file: *mut ::std::os::raw::c_char,
    pub my_cnf_group: *mut ::std::os::raw::c_char,
    pub charset_dir: *mut ::std::os::raw::c_char,
    pub charset_name: *mut ::std::os::raw::c_char,
    pub ssl_key: *mut ::std::os::raw::c_char,
    pub ssl_cert: *mut ::std::os::raw::c_char,
    pub ssl_ca: *mut ::std::os::raw::c_char,
    pub ssl_capath: *mut ::std::os::raw::c_char,
    pub ssl_cipher: *mut ::std::os::raw::c_char,
    pub shared_memory_base_name: *mut ::std::os::raw::c_char,
    pub max_allowed_packet: ::std::os::raw::c_ulong,
    pub use_ssl: my_bool,
    pub compress: my_bool,
    pub named_pipe: my_bool,
    pub unused1: my_bool,
    pub unused2: my_bool,
    pub unused3: my_bool,
    pub unused4: my_bool,
    pub methods_to_use: mysql_option,
    pub ci: st_mysql_options__bindgen_ty_1,
    pub unused5: my_bool,
    pub report_data_truncation: my_bool,
    pub local_infile_init:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut ::std::os::raw::c_void,
                                                   arg2: *const ::std::os::raw::c_char,
                                                   arg3: *mut ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>,
    pub local_infile_read:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                                   arg2: *mut ::std::os::raw::c_char,
                                                   arg3: ::std::os::raw::c_uint)
                                                   -> ::std::os::raw::c_int>,
    pub local_infile_end:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub local_infile_error:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void,
                                                   arg2: *mut ::std::os::raw::c_char,
                                                   arg3: ::std::os::raw::c_uint)
                                                   -> ::std::os::raw::c_int>,
    pub local_infile_userdata: *mut ::std::os::raw::c_void,
    pub extension: *mut st_mysql_options_extention,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_options_st_dynamic_array([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_options__bindgen_ty_1 {
    pub client_ip: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bind_address: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_st_mysql_options__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<st_mysql_options__bindgen_ty_1>(),
               8usize);
    assert_eq!(::std::mem::align_of::<st_mysql_options__bindgen_ty_1>(),
               8usize);
}
impl Clone for st_mysql_options__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_st_mysql_options() {
    assert_eq!(::std::mem::size_of::<st_mysql_options>(), 248usize);
    assert_eq!(::std::mem::align_of::<st_mysql_options>(), 8usize);
}
impl Clone for st_mysql_options {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_status {
    MYSQL_STATUS_READY = 0,
    MYSQL_STATUS_GET_RESULT = 1,
    MYSQL_STATUS_USE_RESULT = 2,
    MYSQL_STATUS_STATEMENT_GET_RESULT = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_protocol_type {
    MYSQL_PROTOCOL_DEFAULT = 0,
    MYSQL_PROTOCOL_TCP = 1,
    MYSQL_PROTOCOL_SOCKET = 2,
    MYSQL_PROTOCOL_PIPE = 3,
    MYSQL_PROTOCOL_MEMORY = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_ssl_mode {
    SSL_MODE_DISABLED = 1,
    SSL_MODE_PREFERRED = 2,
    SSL_MODE_REQUIRED = 3,
    SSL_MODE_VERIFY_CA = 4,
    SSL_MODE_VERIFY_IDENTITY = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct character_set {
    pub number: ::std::os::raw::c_uint,
    pub state: ::std::os::raw::c_uint,
    pub csname: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub comment: *const ::std::os::raw::c_char,
    pub dir: *const ::std::os::raw::c_char,
    pub mbminlen: ::std::os::raw::c_uint,
    pub mbmaxlen: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_character_set() {
    assert_eq!(::std::mem::size_of::<character_set>(), 48usize);
    assert_eq!(::std::mem::align_of::<character_set>(), 8usize);
}
impl Clone for character_set {
    fn clone(&self) -> Self {
        *self
    }
}
pub type MY_CHARSET_INFO = character_set;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_methods([u8; 0]);
#[repr(C)]
pub struct st_mysql_stmt {
    pub mem_root: MEM_ROOT,
    pub list: LIST,
    pub mysql: *mut MYSQL,
    pub params: *mut MYSQL_BIND,
    pub bind: *mut MYSQL_BIND,
    pub fields: *mut MYSQL_FIELD,
    pub result: MYSQL_DATA,
    pub data_cursor: *mut MYSQL_ROWS,
    pub read_row_func:
        ::std::option::Option<unsafe extern "C" fn(stmt: *mut st_mysql_stmt,
                                                   row: *mut *mut ::std::os::raw::c_uchar)
                                                   -> ::std::os::raw::c_int>,
    pub affected_rows: my_ulonglong,
    pub insert_id: my_ulonglong,
    pub stmt_id: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub prefetch_rows: ::std::os::raw::c_ulong,
    pub server_status: ::std::os::raw::c_uint,
    pub last_errno: ::std::os::raw::c_uint,
    pub param_count: ::std::os::raw::c_uint,
    pub field_count: ::std::os::raw::c_uint,
    pub state: enum_mysql_stmt_state,
    pub last_error: [::std::os::raw::c_char; 512usize],
    pub sqlstate: [::std::os::raw::c_char; 6usize],
    pub send_types_to_server: my_bool,
    pub bind_param_done: my_bool,
    pub bind_result_done: ::std::os::raw::c_uchar,
    pub unbuffered_fetch_cancelled: my_bool,
    pub update_max_length: my_bool,
    pub extension: *mut st_mysql_stmt_extension,
}
#[test]
fn bindgen_test_layout_st_mysql_stmt() {
    assert_eq!(::std::mem::size_of::<st_mysql_stmt>(), 880usize);
    assert_eq!(::std::mem::align_of::<st_mysql_stmt>(), 8usize);
}
pub type MYSQL = st_mysql;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_res {
    pub row_count: my_ulonglong,
    pub fields: *mut MYSQL_FIELD,
    pub data: *mut MYSQL_DATA,
    pub data_cursor: *mut MYSQL_ROWS,
    pub lengths: *mut ::std::os::raw::c_ulong,
    pub handle: *mut MYSQL,
    pub methods: *const st_mysql_methods,
    pub row: MYSQL_ROW,
    pub current_row: MYSQL_ROW,
    pub field_alloc: MEM_ROOT,
    pub field_count: ::std::os::raw::c_uint,
    pub current_field: ::std::os::raw::c_uint,
    pub eof: my_bool,
    pub unbuffered_fetch_cancelled: my_bool,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_res() {
    assert_eq!(::std::mem::size_of::<st_mysql_res>(), 184usize);
    assert_eq!(::std::mem::align_of::<st_mysql_res>(), 8usize);
}
impl Clone for st_mysql_res {
    fn clone(&self) -> Self {
        *self
    }
}
pub type MYSQL_RES = st_mysql_res;
extern "C" {
    pub fn mysql_server_init(argc: ::std::os::raw::c_int,
                             argv: *mut *mut ::std::os::raw::c_char,
                             groups: *mut *mut ::std::os::raw::c_char)
                             -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_server_end();
}
extern "C" {
    pub fn mysql_thread_init() -> my_bool;
}
extern "C" {
    pub fn mysql_thread_end();
}
extern "C" {
    pub fn mysql_num_rows(res: *mut MYSQL_RES) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_num_fields(res: *mut MYSQL_RES) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_eof(res: *mut MYSQL_RES) -> my_bool;
}
extern "C" {
    pub fn mysql_fetch_field_direct(res: *mut MYSQL_RES,
                                    fieldnr: ::std::os::raw::c_uint)
                                    -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_fetch_fields(res: *mut MYSQL_RES) -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_row_tell(res: *mut MYSQL_RES) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_field_tell(res: *mut MYSQL_RES) -> MYSQL_FIELD_OFFSET;
}
extern "C" {
    pub fn mysql_field_count(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_affected_rows(mysql: *mut MYSQL) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_insert_id(mysql: *mut MYSQL) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_errno(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_error(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_sqlstate(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_warning_count(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_info(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_thread_id(mysql: *mut MYSQL) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_character_set_name(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_set_character_set(mysql: *mut MYSQL,
                                   csname: *const ::std::os::raw::c_char)
                                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_init(mysql: *mut MYSQL) -> *mut MYSQL;
}
extern "C" {
    pub fn mysql_ssl_set(mysql: *mut MYSQL,
                         key: *const ::std::os::raw::c_char,
                         cert: *const ::std::os::raw::c_char,
                         ca: *const ::std::os::raw::c_char,
                         capath: *const ::std::os::raw::c_char,
                         cipher: *const ::std::os::raw::c_char)
                         -> my_bool;
}
extern "C" {
    pub fn mysql_get_ssl_cipher(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_change_user(mysql: *mut MYSQL,
                             user: *const ::std::os::raw::c_char,
                             passwd: *const ::std::os::raw::c_char,
                             db: *const ::std::os::raw::c_char)
                             -> my_bool;
}
extern "C" {
    pub fn mysql_real_connect(mysql: *mut MYSQL,
                              host: *const ::std::os::raw::c_char,
                              user: *const ::std::os::raw::c_char,
                              passwd: *const ::std::os::raw::c_char,
                              db: *const ::std::os::raw::c_char,
                              port: ::std::os::raw::c_uint,
                              unix_socket: *const ::std::os::raw::c_char,
                              clientflag: ::std::os::raw::c_ulong)
                              -> *mut MYSQL;
}
extern "C" {
    pub fn mysql_select_db(mysql: *mut MYSQL,
                           db: *const ::std::os::raw::c_char)
                           -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_query(mysql: *mut MYSQL,
                       q: *const ::std::os::raw::c_char)
                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_send_query(mysql: *mut MYSQL,
                            q: *const ::std::os::raw::c_char,
                            length: ::std::os::raw::c_ulong)
                            -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_real_query(mysql: *mut MYSQL,
                            q: *const ::std::os::raw::c_char,
                            length: ::std::os::raw::c_ulong)
                            -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_store_result(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_use_result(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_get_character_set_info(mysql: *mut MYSQL, charset: *mut MY_CHARSET_INFO);
}
extern "C" {
    pub fn mysql_session_track_get_first(mysql: *mut MYSQL,
                                         type_: enum_session_state_type,
                                         data: *mut *const ::std::os::raw::c_char,
                                         length: *mut usize)
                                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_session_track_get_next(mysql: *mut MYSQL,
                                        type_: enum_session_state_type,
                                        data: *mut *const ::std::os::raw::c_char,
                                        length: *mut usize)
                                        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_set_local_infile_handler(mysql: *mut MYSQL,
                                          local_infile_init:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *const ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             *mut ::std::os::raw::c_void)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          local_infile_read:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *mut ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             ::std::os::raw::c_uint)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          local_infile_end:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void)>,
                                          local_infile_error:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *mut ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             ::std::os::raw::c_uint)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mysql_set_local_infile_default(mysql: *mut MYSQL);
}
extern "C" {
    pub fn mysql_shutdown(mysql: *mut MYSQL,
                          shutdown_level: mysql_enum_shutdown_level)
                          -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_dump_debug_info(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_refresh(mysql: *mut MYSQL,
                         refresh_options: ::std::os::raw::c_uint)
                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_kill(mysql: *mut MYSQL, pid: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_set_server_option(mysql: *mut MYSQL,
                                   option: enum_mysql_set_option)
                                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_ping(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stat(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_server_info(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_client_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_client_version() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_get_host_info(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_server_version(mysql: *mut MYSQL) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_get_proto_info(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_list_dbs(mysql: *mut MYSQL,
                          wild: *const ::std::os::raw::c_char)
                          -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_list_tables(mysql: *mut MYSQL,
                             wild: *const ::std::os::raw::c_char)
                             -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_list_processes(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_options(mysql: *mut MYSQL,
                         option: mysql_option,
                         arg: *const ::std::os::raw::c_void)
                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_options4(mysql: *mut MYSQL,
                          option: mysql_option,
                          arg1: *const ::std::os::raw::c_void,
                          arg2: *const ::std::os::raw::c_void)
                          -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_get_option(mysql: *mut MYSQL,
                            option: mysql_option,
                            arg: *const ::std::os::raw::c_void)
                            -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_free_result(result: *mut MYSQL_RES);
}
extern "C" {
    pub fn mysql_data_seek(result: *mut MYSQL_RES, offset: my_ulonglong);
}
extern "C" {
    pub fn mysql_row_seek(result: *mut MYSQL_RES, offset: MYSQL_ROW_OFFSET) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_field_seek(result: *mut MYSQL_RES,
                            offset: MYSQL_FIELD_OFFSET)
                            -> MYSQL_FIELD_OFFSET;
}
extern "C" {
    pub fn mysql_fetch_row(result: *mut MYSQL_RES) -> MYSQL_ROW;
}
extern "C" {
    pub fn mysql_fetch_lengths(result: *mut MYSQL_RES) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_fetch_field(result: *mut MYSQL_RES) -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_list_fields(mysql: *mut MYSQL,
                             table: *const ::std::os::raw::c_char,
                             wild: *const ::std::os::raw::c_char)
                             -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_escape_string(to: *mut ::std::os::raw::c_char,
                               from: *const ::std::os::raw::c_char,
                               from_length: ::std::os::raw::c_ulong)
                               -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_hex_string(to: *mut ::std::os::raw::c_char,
                            from: *const ::std::os::raw::c_char,
                            from_length: ::std::os::raw::c_ulong)
                            -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_real_escape_string(mysql: *mut MYSQL,
                                    to: *mut ::std::os::raw::c_char,
                                    from: *const ::std::os::raw::c_char,
                                    length: ::std::os::raw::c_ulong)
                                    -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_real_escape_string_quote(mysql: *mut MYSQL,
                                          to: *mut ::std::os::raw::c_char,
                                          from: *const ::std::os::raw::c_char,
                                          length: ::std::os::raw::c_ulong,
                                          quote: ::std::os::raw::c_char)
                                          -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_debug(debug: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn mysql_thread_safe() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_embedded() -> my_bool;
}
extern "C" {
    pub fn mysql_read_query_result(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_reset_connection(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_mysql_stmt_state {
    MYSQL_STMT_INIT_DONE = 1,
    MYSQL_STMT_PREPARE_DONE = 2,
    MYSQL_STMT_EXECUTE_DONE = 3,
    MYSQL_STMT_FETCH_DONE = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_bind {
    pub length: *mut ::std::os::raw::c_ulong,
    pub is_null: *mut my_bool,
    pub buffer: *mut ::std::os::raw::c_void,
    pub error: *mut my_bool,
    pub row_ptr: *mut ::std::os::raw::c_uchar,
    pub store_param_func:
        ::std::option::Option<unsafe extern "C" fn(net: *mut NET, param: *mut st_mysql_bind)>,
    pub fetch_result:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut st_mysql_bind,
                                                   arg2: *mut MYSQL_FIELD,
                                                   row: *mut *mut ::std::os::raw::c_uchar)>,
    pub skip_result:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut st_mysql_bind,
                                                   arg2: *mut MYSQL_FIELD,
                                                   row: *mut *mut ::std::os::raw::c_uchar)>,
    pub buffer_length: ::std::os::raw::c_ulong,
    pub offset: ::std::os::raw::c_ulong,
    pub length_value: ::std::os::raw::c_ulong,
    pub param_number: ::std::os::raw::c_uint,
    pub pack_length: ::std::os::raw::c_uint,
    pub buffer_type: enum_field_types,
    pub error_value: my_bool,
    pub is_unsigned: my_bool,
    pub long_data_used: my_bool,
    pub is_null_value: my_bool,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_bind() {
    assert_eq!(::std::mem::size_of::<st_mysql_bind>(), 112usize);
    assert_eq!(::std::mem::align_of::<st_mysql_bind>(), 8usize);
}
impl Clone for st_mysql_bind {
    fn clone(&self) -> Self {
        *self
    }
}
pub type MYSQL_BIND = st_mysql_bind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_stmt_extension([u8; 0]);
pub type MYSQL_STMT = st_mysql_stmt;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_stmt_attr_type {
    STMT_ATTR_UPDATE_MAX_LENGTH = 0,
    STMT_ATTR_CURSOR_TYPE = 1,
    STMT_ATTR_PREFETCH_ROWS = 2,
}
extern "C" {
    pub fn mysql_stmt_init(mysql: *mut MYSQL) -> *mut MYSQL_STMT;
}
extern "C" {
    pub fn mysql_stmt_prepare(stmt: *mut MYSQL_STMT,
                              query: *const ::std::os::raw::c_char,
                              length: ::std::os::raw::c_ulong)
                              -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_execute(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_fetch(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_fetch_column(stmt: *mut MYSQL_STMT,
                                   bind_arg: *mut MYSQL_BIND,
                                   column: ::std::os::raw::c_uint,
                                   offset: ::std::os::raw::c_ulong)
                                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_store_result(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_param_count(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_stmt_attr_set(stmt: *mut MYSQL_STMT,
                               attr_type: enum_stmt_attr_type,
                               attr: *const ::std::os::raw::c_void)
                               -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_attr_get(stmt: *mut MYSQL_STMT,
                               attr_type: enum_stmt_attr_type,
                               attr: *mut ::std::os::raw::c_void)
                               -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_bind_param(stmt: *mut MYSQL_STMT, bnd: *mut MYSQL_BIND) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_bind_result(stmt: *mut MYSQL_STMT, bnd: *mut MYSQL_BIND) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_close(stmt: *mut MYSQL_STMT) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_reset(stmt: *mut MYSQL_STMT) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_free_result(stmt: *mut MYSQL_STMT) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_send_long_data(stmt: *mut MYSQL_STMT,
                                     param_number: ::std::os::raw::c_uint,
                                     data: *const ::std::os::raw::c_char,
                                     length: ::std::os::raw::c_ulong)
                                     -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_result_metadata(stmt: *mut MYSQL_STMT) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_stmt_param_metadata(stmt: *mut MYSQL_STMT) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_stmt_errno(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_stmt_error(stmt: *mut MYSQL_STMT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_stmt_sqlstate(stmt: *mut MYSQL_STMT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_stmt_row_seek(stmt: *mut MYSQL_STMT,
                               offset: MYSQL_ROW_OFFSET)
                               -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_stmt_row_tell(stmt: *mut MYSQL_STMT) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_stmt_data_seek(stmt: *mut MYSQL_STMT, offset: my_ulonglong);
}
extern "C" {
    pub fn mysql_stmt_num_rows(stmt: *mut MYSQL_STMT) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_stmt_affected_rows(stmt: *mut MYSQL_STMT) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_stmt_insert_id(stmt: *mut MYSQL_STMT) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_stmt_field_count(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_commit(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_rollback(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_autocommit(mysql: *mut MYSQL, auto_mode: my_bool) -> my_bool;
}
extern "C" {
    pub fn mysql_more_results(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_next_result(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_next_result(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_close(sock: *mut MYSQL);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
