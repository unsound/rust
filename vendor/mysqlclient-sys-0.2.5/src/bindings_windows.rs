/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const MYSQL_SERVER_VERSION: &'static [u8; 7usize] = b"5.7.17\x00";
pub const MYSQL_BASE_VERSION: &'static [u8; 11usize] = b"mysqld-5.7\x00";
pub const MYSQL_SERVER_SUFFIX_DEF: &'static [u8; 1usize] = b"\x00";
pub const MYSQL_VERSION_ID: ::std::os::raw::c_uint = 50717;
pub const MYSQL_PORT: ::std::os::raw::c_uint = 3306;
pub const MYSQL_PORT_DEFAULT: ::std::os::raw::c_uint = 0;
pub const MYSQL_UNIX_ADDR: &'static [u8; 16usize] = b"/tmp/mysql.sock\x00";
pub const MYSQL_CONFIG_NAME: &'static [u8; 3usize] = b"my\x00";
pub const MYSQL_COMPILATION_COMMENT: &'static [u8; 20usize] =
    b"Source distribution\x00";
pub const MYSQL_AUTODETECT_CHARSET_NAME: &'static [u8; 5usize] = b"auto\x00";
pub const MYSQL_NAMEDPIPE: &'static [u8; 6usize] = b"MySQL\x00";
pub const MYSQL_SERVICENAME: &'static [u8; 6usize] = b"MySQL\x00";
pub const MYSQL_ERRMSG_SIZE: ::std::os::raw::c_uint = 512;
pub const MYSQL_STMT_HEADER: ::std::os::raw::c_uint = 4;
pub const MYSQL_LONG_DATA_HEADER: ::std::os::raw::c_uint = 6;
pub const MYSQL_CLIENT_reserved1: ::std::os::raw::c_uint = 0;
pub const MYSQL_CLIENT_reserved2: ::std::os::raw::c_uint = 1;
pub const MYSQL_CLIENT_AUTHENTICATION_PLUGIN: ::std::os::raw::c_uint = 2;
pub const MYSQL_CLIENT_TRACE_PLUGIN: ::std::os::raw::c_uint = 3;
pub const MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION:
          ::std::os::raw::c_uint =
    256;
pub const MYSQL_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION: ::std::os::raw::c_uint
          =
    256;
pub const MYSQL_CLIENT_MAX_PLUGINS: ::std::os::raw::c_uint = 4;
pub const MYSQL_USERNAME_LENGTH: ::std::os::raw::c_uint = 96;
pub const MYSQL_NO_DATA: ::std::os::raw::c_uint = 100;
pub const MYSQL_DATA_TRUNCATED: ::std::os::raw::c_uint = 101;
pub type my_bool = ::std::os::raw::c_char;
pub type va_list = *mut ::std::os::raw::c_char;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type SOCKET = UINT_PTR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_field_types {
    MYSQL_TYPE_DECIMAL = 0,
    MYSQL_TYPE_TINY = 1,
    MYSQL_TYPE_SHORT = 2,
    MYSQL_TYPE_LONG = 3,
    MYSQL_TYPE_FLOAT = 4,
    MYSQL_TYPE_DOUBLE = 5,
    MYSQL_TYPE_NULL = 6,
    MYSQL_TYPE_TIMESTAMP = 7,
    MYSQL_TYPE_LONGLONG = 8,
    MYSQL_TYPE_INT24 = 9,
    MYSQL_TYPE_DATE = 10,
    MYSQL_TYPE_TIME = 11,
    MYSQL_TYPE_DATETIME = 12,
    MYSQL_TYPE_YEAR = 13,
    MYSQL_TYPE_NEWDATE = 14,
    MYSQL_TYPE_VARCHAR = 15,
    MYSQL_TYPE_BIT = 16,
    MYSQL_TYPE_TIMESTAMP2 = 17,
    MYSQL_TYPE_DATETIME2 = 18,
    MYSQL_TYPE_TIME2 = 19,
    MYSQL_TYPE_JSON = 245,
    MYSQL_TYPE_NEWDECIMAL = 246,
    MYSQL_TYPE_ENUM = 247,
    MYSQL_TYPE_SET = 248,
    MYSQL_TYPE_TINY_BLOB = 249,
    MYSQL_TYPE_MEDIUM_BLOB = 250,
    MYSQL_TYPE_LONG_BLOB = 251,
    MYSQL_TYPE_BLOB = 252,
    MYSQL_TYPE_VAR_STRING = 253,
    MYSQL_TYPE_STRING = 254,
    MYSQL_TYPE_GEOMETRY = 255,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_vio {
    _unused: [u8; 0],
}
pub type Vio = st_vio;
#[repr(C)]
pub struct st_net {
    pub vio: *mut Vio,
    pub buff: *mut ::std::os::raw::c_uchar,
    pub buff_end: *mut ::std::os::raw::c_uchar,
    pub write_pos: *mut ::std::os::raw::c_uchar,
    pub read_pos: *mut ::std::os::raw::c_uchar,
    pub fd: SOCKET,
    pub remain_in_buf: ::std::os::raw::c_ulong,
    pub length: ::std::os::raw::c_ulong,
    pub buf_length: ::std::os::raw::c_ulong,
    pub where_b: ::std::os::raw::c_ulong,
    pub max_packet: ::std::os::raw::c_ulong,
    pub max_packet_size: ::std::os::raw::c_ulong,
    pub pkt_nr: ::std::os::raw::c_uint,
    pub compress_pkt_nr: ::std::os::raw::c_uint,
    pub write_timeout: ::std::os::raw::c_uint,
    pub read_timeout: ::std::os::raw::c_uint,
    pub retry_count: ::std::os::raw::c_uint,
    pub fcntl: ::std::os::raw::c_int,
    pub return_status: *mut ::std::os::raw::c_uint,
    pub reading_or_writing: ::std::os::raw::c_uchar,
    pub save_char: ::std::os::raw::c_char,
    pub unused1: my_bool,
    pub unused2: my_bool,
    pub compress: my_bool,
    pub unused3: my_bool,
    pub unused: *mut ::std::os::raw::c_uchar,
    pub last_errno: ::std::os::raw::c_uint,
    pub error: ::std::os::raw::c_uchar,
    pub unused4: my_bool,
    pub unused5: my_bool,
    /** Client library error message buffer. Actually belongs to struct MYSQL. */
    pub last_error: [::std::os::raw::c_char; 512usize],
    /** Client library sqlstate buffer. Set along with the error message. */
    pub sqlstate: [::std::os::raw::c_char; 6usize],
    /**
    Extension pointer, for the caller private use.
    Any program linking with the networking library can use this pointer,
    which is handy when private connection specific data needs to be
    maintained.
    The mysqld server process uses this pointer internally,
    to maintain the server internal instrumentation for the connection.
  */
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_net() {
    assert_eq!(::std::mem::size_of::<st_net>() , 656usize , concat ! (
               "Size of: " , stringify ! ( st_net ) ));
    assert_eq! (::std::mem::align_of::<st_net>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_net ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . vio as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( vio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . buff as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( buff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . buff_end as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( buff_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . write_pos as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( write_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . read_pos as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( read_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . fd as * const _ as usize } ,
                40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . remain_in_buf as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( remain_in_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . length as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . buf_length as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( buf_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . where_b as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( where_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . max_packet as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( max_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . max_packet_size as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( max_packet_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . pkt_nr as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( pkt_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . compress_pkt_nr as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( compress_pkt_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . write_timeout as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( write_timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . read_timeout as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( read_timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . retry_count as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( retry_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . fcntl as * const _ as usize
                } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( fcntl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . return_status as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( return_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . reading_or_writing as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( reading_or_writing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . save_char as * const _ as
                usize } , 105usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( save_char ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . unused1 as * const _ as
                usize } , 106usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( unused1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . unused2 as * const _ as
                usize } , 107usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( unused2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . compress as * const _ as
                usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( compress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . unused3 as * const _ as
                usize } , 109usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( unused3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . unused as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( unused ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . last_errno as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( last_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . error as * const _ as usize
                } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . unused4 as * const _ as
                usize } , 125usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( unused4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . unused5 as * const _ as
                usize } , 126usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( unused5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . last_error as * const _ as
                usize } , 127usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( last_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . sqlstate as * const _ as
                usize } , 639usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( sqlstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_net ) ) . extension as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( st_net ) , "::" ,
                stringify ! ( extension ) ));
}
pub type NET = st_net;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_enum_shutdown_level {
    SHUTDOWN_DEFAULT = 0,
    SHUTDOWN_WAIT_CONNECTIONS = 1,
    SHUTDOWN_WAIT_TRANSACTIONS = 2,
    SHUTDOWN_WAIT_UPDATES = 8,
    SHUTDOWN_WAIT_ALL_BUFFERS = 16,
    SHUTDOWN_WAIT_CRITICAL_BUFFERS = 17,
    KILL_QUERY = 254,
    KILL_CONNECTION = 255,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_mysql_set_option {
    MYSQL_OPTION_MULTI_STATEMENTS_ON = 0,
    MYSQL_OPTION_MULTI_STATEMENTS_OFF = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_session_state_type {
    SESSION_TRACK_SYSTEM_VARIABLES = 0,
    SESSION_TRACK_SCHEMA = 1,
    SESSION_TRACK_STATE_CHANGE = 2,
    SESSION_TRACK_GTIDS = 3,
    SESSION_TRACK_TRANSACTION_CHARACTERISTICS = 4,
    SESSION_TRACK_TRANSACTION_STATE = 5,
}
extern "C" {
    pub fn mysql_errno_to_sqlstate(mysql_errno: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_mysql_timestamp_type {
    MYSQL_TIMESTAMP_NONE = -2,
    MYSQL_TIMESTAMP_ERROR = -1,
    MYSQL_TIMESTAMP_DATE = 0,
    MYSQL_TIMESTAMP_DATETIME = 1,
    MYSQL_TIMESTAMP_TIME = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_time {
    pub year: ::std::os::raw::c_uint,
    pub month: ::std::os::raw::c_uint,
    pub day: ::std::os::raw::c_uint,
    pub hour: ::std::os::raw::c_uint,
    pub minute: ::std::os::raw::c_uint,
    pub second: ::std::os::raw::c_uint,
    /**< microseconds */
    pub second_part: ::std::os::raw::c_ulong,
    pub neg: my_bool,
    pub time_type: enum_mysql_timestamp_type,
}
#[test]
fn bindgen_test_layout_st_mysql_time() {
    assert_eq!(::std::mem::size_of::<st_mysql_time>() , 36usize , concat ! (
               "Size of: " , stringify ! ( st_mysql_time ) ));
    assert_eq! (::std::mem::align_of::<st_mysql_time>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( st_mysql_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_time ) ) . year as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_time ) , "::"
                , stringify ! ( year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_time ) ) . month as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_time ) , "::"
                , stringify ! ( month ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_time ) ) . day as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_time ) , "::"
                , stringify ! ( day ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_time ) ) . hour as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_time ) , "::"
                , stringify ! ( hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_time ) ) . minute as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_time ) , "::"
                , stringify ! ( minute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_time ) ) . second as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_time ) , "::"
                , stringify ! ( second ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_time ) ) . second_part as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_time ) , "::"
                , stringify ! ( second_part ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_time ) ) . neg as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_time ) , "::"
                , stringify ! ( neg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_time ) ) . time_type as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_time ) , "::"
                , stringify ! ( time_type ) ));
}
impl Clone for st_mysql_time {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_TIME = st_mysql_time;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_list {
    pub prev: *mut st_list,
    pub next: *mut st_list,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_list() {
    assert_eq!(::std::mem::size_of::<st_list>() , 24usize , concat ! (
               "Size of: " , stringify ! ( st_list ) ));
    assert_eq! (::std::mem::align_of::<st_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_list ) ) . prev as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_list ) , "::" ,
                stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_list ) ) . next as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_list ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_list ) ) . data as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_list ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for st_list {
    fn clone(&self) -> Self { *self }
}
pub type LIST = st_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_client_plugin {
    pub type_: ::std::os::raw::c_int,
    pub interface_version: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub author: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub version: [::std::os::raw::c_uint; 3usize],
    pub license: *const ::std::os::raw::c_char,
    pub mysql_api: *mut ::std::os::raw::c_void,
    pub init: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             *mut ::std::os::raw::c_char,
                                                         arg2: usize,
                                                         arg3:
                                                             ::std::os::raw::c_int,
                                                         arg4: va_list)
                                        -> ::std::os::raw::c_int>,
    pub deinit: ::std::option::Option<unsafe extern "C" fn()
                                          -> ::std::os::raw::c_int>,
    pub options: ::std::option::Option<unsafe extern "C" fn(option:
                                                                *const ::std::os::raw::c_char,
                                                            arg1:
                                                                *const ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_st_mysql_client_plugin() {
    assert_eq!(::std::mem::size_of::<st_mysql_client_plugin>() , 88usize ,
               concat ! ( "Size of: " , stringify ! ( st_mysql_client_plugin )
               ));
    assert_eq! (::std::mem::align_of::<st_mysql_client_plugin>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( st_mysql_client_plugin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) .
                interface_version as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( interface_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) . name as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) . author as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( author ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) . desc as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) . version as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) . license as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( license ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) . mysql_api as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( mysql_api ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) . init as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) . deinit as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( deinit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_client_plugin ) ) . options as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_client_plugin
                ) , "::" , stringify ! ( options ) ));
}
impl Clone for st_mysql_client_plugin {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct st_mysql {
    pub net: NET,
    pub connector_fd: *mut ::std::os::raw::c_uchar,
    pub host: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub passwd: *mut ::std::os::raw::c_char,
    pub unix_socket: *mut ::std::os::raw::c_char,
    pub server_version: *mut ::std::os::raw::c_char,
    pub host_info: *mut ::std::os::raw::c_char,
    pub info: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub charset: *mut charset_info_st,
    pub fields: *mut MYSQL_FIELD,
    pub field_alloc: MEM_ROOT,
    pub affected_rows: my_ulonglong,
    pub insert_id: my_ulonglong,
    pub extra_info: my_ulonglong,
    pub thread_id: ::std::os::raw::c_ulong,
    pub packet_length: ::std::os::raw::c_ulong,
    pub port: ::std::os::raw::c_uint,
    pub client_flag: ::std::os::raw::c_ulong,
    pub server_capabilities: ::std::os::raw::c_ulong,
    pub protocol_version: ::std::os::raw::c_uint,
    pub field_count: ::std::os::raw::c_uint,
    pub server_status: ::std::os::raw::c_uint,
    pub server_language: ::std::os::raw::c_uint,
    pub warning_count: ::std::os::raw::c_uint,
    pub options: st_mysql_options,
    pub status: mysql_status,
    pub free_me: my_bool,
    pub reconnect: my_bool,
    pub scramble: [::std::os::raw::c_char; 21usize],
    pub unused1: my_bool,
    pub unused2: *mut ::std::os::raw::c_void,
    pub unused3: *mut ::std::os::raw::c_void,
    pub unused4: *mut ::std::os::raw::c_void,
    pub unused5: *mut ::std::os::raw::c_void,
    pub stmts: *mut LIST,
    pub methods: *const st_mysql_methods,
    pub thd: *mut ::std::os::raw::c_void,
    pub unbuffered_fetch_owner: *mut my_bool,
    pub info_buffer: *mut ::std::os::raw::c_char,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql() {
    assert_eq!(::std::mem::size_of::<st_mysql>() , 1240usize , concat ! (
               "Size of: " , stringify ! ( st_mysql ) ));
    assert_eq! (::std::mem::align_of::<st_mysql>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_mysql ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . net as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( net ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . connector_fd as * const _
                as usize } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( connector_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . host as * const _ as usize
                } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( host ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . user as * const _ as usize
                } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . passwd as * const _ as
                usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( passwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . unix_socket as * const _
                as usize } , 688usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( unix_socket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . server_version as * const
                _ as usize } , 696usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( server_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . host_info as * const _ as
                usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( host_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . info as * const _ as usize
                } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . db as * const _ as usize }
                , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( db ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . charset as * const _ as
                usize } , 728usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( charset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . fields as * const _ as
                usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( fields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . field_alloc as * const _
                as usize } , 744usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( field_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . affected_rows as * const _
                as usize } , 832usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( affected_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . insert_id as * const _ as
                usize } , 840usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( insert_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . extra_info as * const _ as
                usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( extra_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . thread_id as * const _ as
                usize } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( thread_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . packet_length as * const _
                as usize } , 860usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( packet_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . port as * const _ as usize
                } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . client_flag as * const _
                as usize } , 868usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( client_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . server_capabilities as *
                const _ as usize } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( server_capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . protocol_version as *
                const _ as usize } , 876usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( protocol_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . field_count as * const _
                as usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( field_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . server_status as * const _
                as usize } , 884usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( server_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . server_language as * const
                _ as usize } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( server_language ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . warning_count as * const _
                as usize } , 892usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( warning_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . options as * const _ as
                usize } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . status as * const _ as
                usize } , 1128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . free_me as * const _ as
                usize } , 1132usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( free_me ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . reconnect as * const _ as
                usize } , 1133usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( reconnect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . scramble as * const _ as
                usize } , 1134usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( scramble ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . unused1 as * const _ as
                usize } , 1155usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( unused1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . unused2 as * const _ as
                usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( unused2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . unused3 as * const _ as
                usize } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( unused3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . unused4 as * const _ as
                usize } , 1176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( unused4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . unused5 as * const _ as
                usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( unused5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . stmts as * const _ as
                usize } , 1192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( stmts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . methods as * const _ as
                usize } , 1200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . thd as * const _ as usize
                } , 1208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( thd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . unbuffered_fetch_owner as
                * const _ as usize } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( unbuffered_fetch_owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . info_buffer as * const _
                as usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( info_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql ) ) . extension as * const _ as
                usize } , 1232usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql ) , "::" ,
                stringify ! ( extension ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_plugin_vio_info {
    pub protocol: st_plugin_vio_info__bindgen_ty_1,
    /**< it's set, if the protocol is SOCKET or TCP */
    pub socket: ::std::os::raw::c_int,
    /**< it's set, if the protocol is PIPE or MEMORY */
    pub handle: HANDLE,
}
pub const st_plugin_vio_info_MYSQL_VIO_INVALID:
          st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_INVALID;
pub const st_plugin_vio_info_MYSQL_VIO_TCP: st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_TCP;
pub const st_plugin_vio_info_MYSQL_VIO_SOCKET:
          st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_SOCKET;
pub const st_plugin_vio_info_MYSQL_VIO_PIPE: st_plugin_vio_info__bindgen_ty_1
          =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_PIPE;
pub const st_plugin_vio_info_MYSQL_VIO_MEMORY:
          st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_MEMORY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum st_plugin_vio_info__bindgen_ty_1 {
    MYSQL_VIO_INVALID = 0,
    MYSQL_VIO_TCP = 1,
    MYSQL_VIO_SOCKET = 2,
    MYSQL_VIO_PIPE = 3,
    MYSQL_VIO_MEMORY = 4,
}
#[test]
fn bindgen_test_layout_st_plugin_vio_info() {
    assert_eq!(::std::mem::size_of::<st_plugin_vio_info>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( st_plugin_vio_info ) ));
    assert_eq! (::std::mem::align_of::<st_plugin_vio_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( st_plugin_vio_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_plugin_vio_info ) ) . protocol as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_plugin_vio_info ) ,
                "::" , stringify ! ( protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_plugin_vio_info ) ) . socket as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( st_plugin_vio_info ) ,
                "::" , stringify ! ( socket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_plugin_vio_info ) ) . handle as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_plugin_vio_info ) ,
                "::" , stringify ! ( handle ) ));
}
impl Clone for st_plugin_vio_info {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_PLUGIN_VIO_INFO = st_plugin_vio_info;
/**
  Provides plugin access to communication channel
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_plugin_vio {
    /**
    Plugin provides a pointer reference and this function sets it to the
    contents of any incoming packet. Returns the packet length, or -1 if
    the plugin should terminate.
  */
    pub read_packet: ::std::option::Option<unsafe extern "C" fn(vio:
                                                                    *mut st_plugin_vio,
                                                                buf:
                                                                    *mut *mut ::std::os::raw::c_uchar)
                                               -> ::std::os::raw::c_int>,
    /**
    Plugin provides a buffer with data and the length and this
    function sends it as a packet. Returns 0 on success, 1 on failure.
  */
    pub write_packet: ::std::option::Option<unsafe extern "C" fn(vio:
                                                                     *mut st_plugin_vio,
                                                                 packet:
                                                                     *const ::std::os::raw::c_uchar,
                                                                 packet_len:
                                                                     ::std::os::raw::c_int)
                                                -> ::std::os::raw::c_int>,
    /**
    Fills in a st_plugin_vio_info structure, providing the information
    about the connection.
  */
    pub info: ::std::option::Option<unsafe extern "C" fn(vio:
                                                             *mut st_plugin_vio,
                                                         info:
                                                             *mut st_plugin_vio_info)>,
}
#[test]
fn bindgen_test_layout_st_plugin_vio() {
    assert_eq!(::std::mem::size_of::<st_plugin_vio>() , 24usize , concat ! (
               "Size of: " , stringify ! ( st_plugin_vio ) ));
    assert_eq! (::std::mem::align_of::<st_plugin_vio>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_plugin_vio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_plugin_vio ) ) . read_packet as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_plugin_vio ) , "::"
                , stringify ! ( read_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_plugin_vio ) ) . write_packet as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_plugin_vio ) , "::"
                , stringify ! ( write_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_plugin_vio ) ) . info as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_plugin_vio ) , "::"
                , stringify ! ( info ) ));
}
impl Clone for st_plugin_vio {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_PLUGIN_VIO = st_plugin_vio;
extern "C" {
    /**
  loads a plugin and initializes it

  @param mysql  MYSQL structure.
  @param name   a name of the plugin to load
  @param type   type of plugin that should be loaded, -1 to disable type check
  @param argc   number of arguments to pass to the plugin initialization
                function
  @param ...    arguments for the plugin initialization function

  @retval
  a pointer to the loaded plugin, or NULL in case of a failure
*/
    pub fn mysql_load_plugin(mysql: *mut st_mysql,
                             name: *const ::std::os::raw::c_char,
                             type_: ::std::os::raw::c_int,
                             argc: ::std::os::raw::c_int, ...)
     -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  loads a plugin and initializes it, taking va_list as an argument

  This is the same as mysql_load_plugin, but take va_list instead of
  a list of arguments.

  @param mysql  MYSQL structure.
  @param name   a name of the plugin to load
  @param type   type of plugin that should be loaded, -1 to disable type check
  @param argc   number of arguments to pass to the plugin initialization
                function
  @param args   arguments for the plugin initialization function

  @retval
  a pointer to the loaded plugin, or NULL in case of a failure
*/
    pub fn mysql_load_plugin_v(mysql: *mut st_mysql,
                               name: *const ::std::os::raw::c_char,
                               type_: ::std::os::raw::c_int,
                               argc: ::std::os::raw::c_int, args: va_list)
     -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  finds an already loaded plugin by name, or loads it, if necessary

  @param mysql  MYSQL structure.
  @param name   a name of the plugin to load
  @param type   type of plugin that should be loaded

  @retval
  a pointer to the plugin, or NULL in case of a failure
*/
    pub fn mysql_client_find_plugin(mysql: *mut st_mysql,
                                    name: *const ::std::os::raw::c_char,
                                    type_: ::std::os::raw::c_int)
     -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  adds a plugin structure to the list of loaded plugins

  This is useful if an application has the necessary functionality
  (for example, a special load data handler) statically linked into
  the application binary. It can use this function to register the plugin
  directly, avoiding the need to factor it out into a shared object.

  @param mysql  MYSQL structure. It is only used for error reporting
  @param plugin an st_mysql_client_plugin structure to register

  @retval
  a pointer to the plugin, or NULL in case of a failure
*/
    pub fn mysql_client_register_plugin(mysql: *mut st_mysql,
                                        plugin: *mut st_mysql_client_plugin)
     -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  set plugin options

  Can be used to set extra options and affect behavior for a plugin.
  This function may be called multiple times to set several options

  @param plugin an st_mysql_client_plugin structure
  @param option a string which specifies the option to set
  @param value  value for the option.

  @retval 0 on success, 1 in case of failure
**/
    pub fn mysql_plugin_options(plugin: *mut st_mysql_client_plugin,
                                option: *const ::std::os::raw::c_char,
                                value: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_field {
    pub name: *mut ::std::os::raw::c_char,
    pub org_name: *mut ::std::os::raw::c_char,
    pub table: *mut ::std::os::raw::c_char,
    pub org_table: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub catalog: *mut ::std::os::raw::c_char,
    pub def: *mut ::std::os::raw::c_char,
    pub length: ::std::os::raw::c_ulong,
    pub max_length: ::std::os::raw::c_ulong,
    pub name_length: ::std::os::raw::c_uint,
    pub org_name_length: ::std::os::raw::c_uint,
    pub table_length: ::std::os::raw::c_uint,
    pub org_table_length: ::std::os::raw::c_uint,
    pub db_length: ::std::os::raw::c_uint,
    pub catalog_length: ::std::os::raw::c_uint,
    pub def_length: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub decimals: ::std::os::raw::c_uint,
    pub charsetnr: ::std::os::raw::c_uint,
    pub type_: enum_field_types,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_field() {
    assert_eq!(::std::mem::size_of::<st_mysql_field>() , 120usize , concat ! (
               "Size of: " , stringify ! ( st_mysql_field ) ));
    assert_eq! (::std::mem::align_of::<st_mysql_field>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_mysql_field ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . org_name as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( org_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . table as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . org_table as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( org_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . db as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( db ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . catalog as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( catalog ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . def as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( def ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . length as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . max_length as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( max_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . name_length as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( name_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . org_name_length as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( org_name_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . table_length as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( table_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . org_table_length as
                * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( org_table_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . db_length as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( db_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . catalog_length as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( catalog_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . def_length as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( def_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . flags as * const _
                as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . decimals as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( decimals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . charsetnr as * const
                _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( charsetnr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . type_ as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_field ) ) . extension as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_field ) , "::"
                , stringify ! ( extension ) ));
}
impl Clone for st_mysql_field {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_FIELD = st_mysql_field;
pub type MYSQL_ROW = *mut *mut ::std::os::raw::c_char;
pub type MYSQL_FIELD_OFFSET = ::std::os::raw::c_uint;
pub type my_ulonglong = ::std::os::raw::c_ulonglong;
/**
  Instrumented memory key.
  To instrument memory, a memory key must be obtained using @c register_memory.
  Using a zero key always disable the instrumentation.
*/
pub type PSI_memory_key = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_used_mem {
    pub next: *mut st_used_mem,
    pub left: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_st_used_mem() {
    assert_eq!(::std::mem::size_of::<st_used_mem>() , 16usize , concat ! (
               "Size of: " , stringify ! ( st_used_mem ) ));
    assert_eq! (::std::mem::align_of::<st_used_mem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_used_mem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_used_mem ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_used_mem ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_used_mem ) ) . left as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_used_mem ) , "::" ,
                stringify ! ( left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_used_mem ) ) . size as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( st_used_mem ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for st_used_mem {
    fn clone(&self) -> Self { *self }
}
pub type USED_MEM = st_used_mem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mem_root {
    pub free: *mut USED_MEM,
    pub used: *mut USED_MEM,
    pub pre_alloc: *mut USED_MEM,
    pub min_malloc: usize,
    pub block_size: usize,
    pub block_num: ::std::os::raw::c_uint,
    pub first_block_usage: ::std::os::raw::c_uint,
    pub max_capacity: usize,
    pub allocated_size: usize,
    pub error_for_capacity_exceeded: my_bool,
    pub error_handler: ::std::option::Option<unsafe extern "C" fn()>,
    pub m_psi_key: PSI_memory_key,
}
#[test]
fn bindgen_test_layout_st_mem_root() {
    assert_eq!(::std::mem::size_of::<st_mem_root>() , 88usize , concat ! (
               "Size of: " , stringify ! ( st_mem_root ) ));
    assert_eq! (::std::mem::align_of::<st_mem_root>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_mem_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . free as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . used as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . pre_alloc as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( pre_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . min_malloc as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( min_malloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . block_size as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( block_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . block_num as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( block_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . first_block_usage as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( first_block_usage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . max_capacity as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( max_capacity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . allocated_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( allocated_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) .
                error_for_capacity_exceeded as * const _ as usize } , 64usize
                , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( error_for_capacity_exceeded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . error_handler as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( error_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mem_root ) ) . m_psi_key as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mem_root ) , "::" ,
                stringify ! ( m_psi_key ) ));
}
impl Clone for st_mem_root {
    fn clone(&self) -> Self { *self }
}
pub type MEM_ROOT = st_mem_root;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_rows {
    pub next: *mut st_mysql_rows,
    pub data: MYSQL_ROW,
    pub length: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_mysql_rows() {
    assert_eq!(::std::mem::size_of::<st_mysql_rows>() , 24usize , concat ! (
               "Size of: " , stringify ! ( st_mysql_rows ) ));
    assert_eq! (::std::mem::align_of::<st_mysql_rows>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_mysql_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_rows ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_rows ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_rows ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_rows ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_rows ) ) . length as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_rows ) , "::"
                , stringify ! ( length ) ));
}
impl Clone for st_mysql_rows {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_ROWS = st_mysql_rows;
pub type MYSQL_ROW_OFFSET = *mut MYSQL_ROWS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct embedded_query_result {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_data {
    pub data: *mut MYSQL_ROWS,
    pub embedded_info: *mut embedded_query_result,
    pub alloc: MEM_ROOT,
    pub rows: my_ulonglong,
    pub fields: ::std::os::raw::c_uint,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_data() {
    assert_eq!(::std::mem::size_of::<st_mysql_data>() , 128usize , concat ! (
               "Size of: " , stringify ! ( st_mysql_data ) ));
    assert_eq! (::std::mem::align_of::<st_mysql_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_mysql_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_data ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_data ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_data ) ) . embedded_info as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_data ) , "::"
                , stringify ! ( embedded_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_data ) ) . alloc as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_data ) , "::"
                , stringify ! ( alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_data ) ) . rows as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_data ) , "::"
                , stringify ! ( rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_data ) ) . fields as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_data ) , "::"
                , stringify ! ( fields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_data ) ) . extension as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_data ) , "::"
                , stringify ! ( extension ) ));
}
impl Clone for st_mysql_data {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_DATA = st_mysql_data;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_option {
    MYSQL_OPT_CONNECT_TIMEOUT = 0,
    MYSQL_OPT_COMPRESS = 1,
    MYSQL_OPT_NAMED_PIPE = 2,
    MYSQL_INIT_COMMAND = 3,
    MYSQL_READ_DEFAULT_FILE = 4,
    MYSQL_READ_DEFAULT_GROUP = 5,
    MYSQL_SET_CHARSET_DIR = 6,
    MYSQL_SET_CHARSET_NAME = 7,
    MYSQL_OPT_LOCAL_INFILE = 8,
    MYSQL_OPT_PROTOCOL = 9,
    MYSQL_SHARED_MEMORY_BASE_NAME = 10,
    MYSQL_OPT_READ_TIMEOUT = 11,
    MYSQL_OPT_WRITE_TIMEOUT = 12,
    MYSQL_OPT_USE_RESULT = 13,
    MYSQL_OPT_USE_REMOTE_CONNECTION = 14,
    MYSQL_OPT_USE_EMBEDDED_CONNECTION = 15,
    MYSQL_OPT_GUESS_CONNECTION = 16,
    MYSQL_SET_CLIENT_IP = 17,
    MYSQL_SECURE_AUTH = 18,
    MYSQL_REPORT_DATA_TRUNCATION = 19,
    MYSQL_OPT_RECONNECT = 20,
    MYSQL_OPT_SSL_VERIFY_SERVER_CERT = 21,
    MYSQL_PLUGIN_DIR = 22,
    MYSQL_DEFAULT_AUTH = 23,
    MYSQL_OPT_BIND = 24,
    MYSQL_OPT_SSL_KEY = 25,
    MYSQL_OPT_SSL_CERT = 26,
    MYSQL_OPT_SSL_CA = 27,
    MYSQL_OPT_SSL_CAPATH = 28,
    MYSQL_OPT_SSL_CIPHER = 29,
    MYSQL_OPT_SSL_CRL = 30,
    MYSQL_OPT_SSL_CRLPATH = 31,
    MYSQL_OPT_CONNECT_ATTR_RESET = 32,
    MYSQL_OPT_CONNECT_ATTR_ADD = 33,
    MYSQL_OPT_CONNECT_ATTR_DELETE = 34,
    MYSQL_SERVER_PUBLIC_KEY = 35,
    MYSQL_ENABLE_CLEARTEXT_PLUGIN = 36,
    MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS = 37,
    MYSQL_OPT_SSL_ENFORCE = 38,
    MYSQL_OPT_MAX_ALLOWED_PACKET = 39,
    MYSQL_OPT_NET_BUFFER_LENGTH = 40,
    MYSQL_OPT_TLS_VERSION = 41,
    MYSQL_OPT_SSL_MODE = 42,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_options_extention {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_options {
    pub connect_timeout: ::std::os::raw::c_uint,
    pub read_timeout: ::std::os::raw::c_uint,
    pub write_timeout: ::std::os::raw::c_uint,
    pub port: ::std::os::raw::c_uint,
    pub protocol: ::std::os::raw::c_uint,
    pub client_flag: ::std::os::raw::c_ulong,
    pub host: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub password: *mut ::std::os::raw::c_char,
    pub unix_socket: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub init_commands: *mut st_dynamic_array,
    pub my_cnf_file: *mut ::std::os::raw::c_char,
    pub my_cnf_group: *mut ::std::os::raw::c_char,
    pub charset_dir: *mut ::std::os::raw::c_char,
    pub charset_name: *mut ::std::os::raw::c_char,
    pub ssl_key: *mut ::std::os::raw::c_char,
    pub ssl_cert: *mut ::std::os::raw::c_char,
    pub ssl_ca: *mut ::std::os::raw::c_char,
    pub ssl_capath: *mut ::std::os::raw::c_char,
    pub ssl_cipher: *mut ::std::os::raw::c_char,
    pub shared_memory_base_name: *mut ::std::os::raw::c_char,
    pub max_allowed_packet: ::std::os::raw::c_ulong,
    pub use_ssl: my_bool,
    pub compress: my_bool,
    pub named_pipe: my_bool,
    pub unused1: my_bool,
    pub unused2: my_bool,
    pub unused3: my_bool,
    pub unused4: my_bool,
    pub methods_to_use: mysql_option,
    pub ci: st_mysql_options__bindgen_ty_1,
    pub unused5: my_bool,
    pub report_data_truncation: my_bool,
    pub local_infile_init: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut *mut ::std::os::raw::c_void,
                                                                      arg2:
                                                                          *const ::std::os::raw::c_char,
                                                                      arg3:
                                                                          *mut ::std::os::raw::c_void)
                                                     ->
                                                         ::std::os::raw::c_int>,
    pub local_infile_read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void,
                                                                      arg2:
                                                                          *mut ::std::os::raw::c_char,
                                                                      arg3:
                                                                          ::std::os::raw::c_uint)
                                                     ->
                                                         ::std::os::raw::c_int>,
    pub local_infile_end: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>,
    pub local_infile_error: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::std::os::raw::c_void,
                                                                       arg2:
                                                                           *mut ::std::os::raw::c_char,
                                                                       arg3:
                                                                           ::std::os::raw::c_uint)
                                                      ->
                                                          ::std::os::raw::c_int>,
    pub local_infile_userdata: *mut ::std::os::raw::c_void,
    pub extension: *mut st_mysql_options_extention,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_options__bindgen_ty_1 {
    pub client_ip: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bind_address: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_st_mysql_options__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<st_mysql_options__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( st_mysql_options__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<st_mysql_options__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( st_mysql_options__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options__bindgen_ty_1 ) ) .
                client_ip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                st_mysql_options__bindgen_ty_1 ) , "::" , stringify ! (
                client_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options__bindgen_ty_1 ) ) .
                bind_address as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                st_mysql_options__bindgen_ty_1 ) , "::" , stringify ! (
                bind_address ) ));
}
impl Clone for st_mysql_options__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_st_mysql_options() {
    assert_eq!(::std::mem::size_of::<st_mysql_options>() , 232usize , concat !
               ( "Size of: " , stringify ! ( st_mysql_options ) ));
    assert_eq! (::std::mem::align_of::<st_mysql_options>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( st_mysql_options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . connect_timeout as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( connect_timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . read_timeout as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( read_timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . write_timeout as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( write_timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . port as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . protocol as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . client_flag as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( client_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . host as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( host ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . user as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . password as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( password ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . unix_socket as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( unix_socket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . db as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( db ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . init_commands as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( init_commands ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . my_cnf_file as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( my_cnf_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . my_cnf_group as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( my_cnf_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . charset_dir as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( charset_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . charset_name as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( charset_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . ssl_key as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( ssl_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . ssl_cert as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( ssl_cert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . ssl_ca as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( ssl_ca ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . ssl_capath as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( ssl_capath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . ssl_cipher as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( ssl_cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) .
                shared_memory_base_name as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( shared_memory_base_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . max_allowed_packet
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( max_allowed_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . use_ssl as * const
                _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( use_ssl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . compress as *
                const _ as usize } , 157usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( compress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . named_pipe as *
                const _ as usize } , 158usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( named_pipe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . unused1 as * const
                _ as usize } , 159usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( unused1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . unused2 as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( unused2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . unused3 as * const
                _ as usize } , 161usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( unused3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . unused4 as * const
                _ as usize } , 162usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( unused4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . methods_to_use as
                * const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( methods_to_use ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . ci as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( ci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . unused5 as * const
                _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( unused5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) .
                report_data_truncation as * const _ as usize } , 177usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( report_data_truncation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . local_infile_init
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( local_infile_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . local_infile_read
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( local_infile_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . local_infile_end
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( local_infile_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . local_infile_error
                as * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( local_infile_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) .
                local_infile_userdata as * const _ as usize } , 216usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( local_infile_userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_options ) ) . extension as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_options ) ,
                "::" , stringify ! ( extension ) ));
}
impl Clone for st_mysql_options {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_status {
    MYSQL_STATUS_READY = 0,
    MYSQL_STATUS_GET_RESULT = 1,
    MYSQL_STATUS_USE_RESULT = 2,
    MYSQL_STATUS_STATEMENT_GET_RESULT = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_ssl_mode {
    SSL_MODE_DISABLED = 1,
    SSL_MODE_PREFERRED = 2,
    SSL_MODE_REQUIRED = 3,
    SSL_MODE_VERIFY_CA = 4,
    SSL_MODE_VERIFY_IDENTITY = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct character_set {
    pub number: ::std::os::raw::c_uint,
    pub state: ::std::os::raw::c_uint,
    pub csname: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub comment: *const ::std::os::raw::c_char,
    pub dir: *const ::std::os::raw::c_char,
    pub mbminlen: ::std::os::raw::c_uint,
    pub mbmaxlen: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_character_set() {
    assert_eq!(::std::mem::size_of::<character_set>() , 48usize , concat ! (
               "Size of: " , stringify ! ( character_set ) ));
    assert_eq! (::std::mem::align_of::<character_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( character_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const character_set ) ) . number as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( character_set ) , "::"
                , stringify ! ( number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const character_set ) ) . state as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( character_set ) , "::"
                , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const character_set ) ) . csname as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( character_set ) , "::"
                , stringify ! ( csname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const character_set ) ) . name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( character_set ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const character_set ) ) . comment as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( character_set ) , "::"
                , stringify ! ( comment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const character_set ) ) . dir as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( character_set ) , "::"
                , stringify ! ( dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const character_set ) ) . mbminlen as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( character_set ) , "::"
                , stringify ! ( mbminlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const character_set ) ) . mbmaxlen as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( character_set ) , "::"
                , stringify ! ( mbmaxlen ) ));
}
impl Clone for character_set {
    fn clone(&self) -> Self { *self }
}
pub type MY_CHARSET_INFO = character_set;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_methods {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct st_mysql_stmt {
    pub mem_root: MEM_ROOT,
    pub list: LIST,
    pub mysql: *mut MYSQL,
    pub params: *mut MYSQL_BIND,
    pub bind: *mut MYSQL_BIND,
    pub fields: *mut MYSQL_FIELD,
    pub result: MYSQL_DATA,
    pub data_cursor: *mut MYSQL_ROWS,
    pub read_row_func: ::std::option::Option<unsafe extern "C" fn(stmt:
                                                                      *mut st_mysql_stmt,
                                                                  row:
                                                                      *mut *mut ::std::os::raw::c_uchar)
                                                 -> ::std::os::raw::c_int>,
    pub affected_rows: my_ulonglong,
    pub insert_id: my_ulonglong,
    pub stmt_id: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub prefetch_rows: ::std::os::raw::c_ulong,
    pub server_status: ::std::os::raw::c_uint,
    pub last_errno: ::std::os::raw::c_uint,
    pub param_count: ::std::os::raw::c_uint,
    pub field_count: ::std::os::raw::c_uint,
    pub state: enum_mysql_stmt_state,
    pub last_error: [::std::os::raw::c_char; 512usize],
    pub sqlstate: [::std::os::raw::c_char; 6usize],
    pub send_types_to_server: my_bool,
    pub bind_param_done: my_bool,
    pub bind_result_done: ::std::os::raw::c_uchar,
    pub unbuffered_fetch_cancelled: my_bool,
    pub update_max_length: my_bool,
    pub extension: *mut st_mysql_stmt_extension,
}
#[test]
fn bindgen_test_layout_st_mysql_stmt() {
    assert_eq!(::std::mem::size_of::<st_mysql_stmt>() , 872usize , concat ! (
               "Size of: " , stringify ! ( st_mysql_stmt ) ));
    assert_eq! (::std::mem::align_of::<st_mysql_stmt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_mysql_stmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . mem_root as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( mem_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . list as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . mysql as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( mysql ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . params as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . bind as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( bind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . fields as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( fields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . result as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( result ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . data_cursor as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( data_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . read_row_func as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( read_row_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . affected_rows as *
                const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( affected_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . insert_id as * const
                _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( insert_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . stmt_id as * const _
                as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( stmt_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . flags as * const _ as
                usize } , 308usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . prefetch_rows as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( prefetch_rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . server_status as *
                const _ as usize } , 316usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( server_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . last_errno as * const
                _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( last_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . param_count as *
                const _ as usize } , 324usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( param_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . field_count as *
                const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( field_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . state as * const _ as
                usize } , 332usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . last_error as * const
                _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( last_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . sqlstate as * const _
                as usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( sqlstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . send_types_to_server
                as * const _ as usize } , 854usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( send_types_to_server ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . bind_param_done as *
                const _ as usize } , 855usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( bind_param_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . bind_result_done as *
                const _ as usize } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( bind_result_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) .
                unbuffered_fetch_cancelled as * const _ as usize } , 857usize
                , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( unbuffered_fetch_cancelled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . update_max_length as
                * const _ as usize } , 858usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( update_max_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_stmt ) ) . extension as * const
                _ as usize } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_stmt ) , "::"
                , stringify ! ( extension ) ));
}
pub type MYSQL = st_mysql;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_res {
    pub row_count: my_ulonglong,
    pub fields: *mut MYSQL_FIELD,
    pub data: *mut MYSQL_DATA,
    pub data_cursor: *mut MYSQL_ROWS,
    pub lengths: *mut ::std::os::raw::c_ulong,
    pub handle: *mut MYSQL,
    pub methods: *const st_mysql_methods,
    pub row: MYSQL_ROW,
    pub current_row: MYSQL_ROW,
    pub field_alloc: MEM_ROOT,
    pub field_count: ::std::os::raw::c_uint,
    pub current_field: ::std::os::raw::c_uint,
    pub eof: my_bool,
    pub unbuffered_fetch_cancelled: my_bool,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_res() {
    assert_eq!(::std::mem::size_of::<st_mysql_res>() , 184usize , concat ! (
               "Size of: " , stringify ! ( st_mysql_res ) ));
    assert_eq! (::std::mem::align_of::<st_mysql_res>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_mysql_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . row_count as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( row_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . fields as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( fields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . data_cursor as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( data_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . lengths as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( lengths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . handle as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . methods as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . row as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . current_row as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( current_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . field_alloc as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( field_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . field_count as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( field_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . current_field as *
                const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( current_field ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . eof as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( eof ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) .
                unbuffered_fetch_cancelled as * const _ as usize } , 169usize
                , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( unbuffered_fetch_cancelled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_res ) ) . extension as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_res ) , "::" ,
                stringify ! ( extension ) ));
}
impl Clone for st_mysql_res {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_RES = st_mysql_res;
extern "C" {
    pub fn mysql_server_init(argc: ::std::os::raw::c_int,
                             argv: *mut *mut ::std::os::raw::c_char,
                             groups: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_server_end();
}
extern "C" {
    pub fn mysql_thread_init() -> my_bool;
}
extern "C" {
    pub fn mysql_thread_end();
}
extern "C" {
    pub fn mysql_num_rows(res: *mut MYSQL_RES) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_num_fields(res: *mut MYSQL_RES) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_eof(res: *mut MYSQL_RES) -> my_bool;
}
extern "C" {
    pub fn mysql_fetch_field_direct(res: *mut MYSQL_RES,
                                    fieldnr: ::std::os::raw::c_uint)
     -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_fetch_fields(res: *mut MYSQL_RES) -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_row_tell(res: *mut MYSQL_RES) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_field_tell(res: *mut MYSQL_RES) -> MYSQL_FIELD_OFFSET;
}
extern "C" {
    pub fn mysql_field_count(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_affected_rows(mysql: *mut MYSQL) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_insert_id(mysql: *mut MYSQL) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_errno(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_error(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_sqlstate(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_warning_count(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_info(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_thread_id(mysql: *mut MYSQL) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_character_set_name(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_set_character_set(mysql: *mut MYSQL,
                                   csname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_init(mysql: *mut MYSQL) -> *mut MYSQL;
}
extern "C" {
    pub fn mysql_ssl_set(mysql: *mut MYSQL,
                         key: *const ::std::os::raw::c_char,
                         cert: *const ::std::os::raw::c_char,
                         ca: *const ::std::os::raw::c_char,
                         capath: *const ::std::os::raw::c_char,
                         cipher: *const ::std::os::raw::c_char) -> my_bool;
}
extern "C" {
    pub fn mysql_get_ssl_cipher(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_change_user(mysql: *mut MYSQL,
                             user: *const ::std::os::raw::c_char,
                             passwd: *const ::std::os::raw::c_char,
                             db: *const ::std::os::raw::c_char) -> my_bool;
}
extern "C" {
    pub fn mysql_real_connect(mysql: *mut MYSQL,
                              host: *const ::std::os::raw::c_char,
                              user: *const ::std::os::raw::c_char,
                              passwd: *const ::std::os::raw::c_char,
                              db: *const ::std::os::raw::c_char,
                              port: ::std::os::raw::c_uint,
                              unix_socket: *const ::std::os::raw::c_char,
                              clientflag: ::std::os::raw::c_ulong)
     -> *mut MYSQL;
}
extern "C" {
    pub fn mysql_select_db(mysql: *mut MYSQL,
                           db: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_query(mysql: *mut MYSQL, q: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_send_query(mysql: *mut MYSQL,
                            q: *const ::std::os::raw::c_char,
                            length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_real_query(mysql: *mut MYSQL,
                            q: *const ::std::os::raw::c_char,
                            length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_store_result(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_use_result(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_get_character_set_info(mysql: *mut MYSQL,
                                        charset: *mut MY_CHARSET_INFO);
}
extern "C" {
    pub fn mysql_session_track_get_first(mysql: *mut MYSQL,
                                         type_: enum_session_state_type,
                                         data:
                                             *mut *const ::std::os::raw::c_char,
                                         length: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_session_track_get_next(mysql: *mut MYSQL,
                                        type_: enum_session_state_type,
                                        data:
                                            *mut *const ::std::os::raw::c_char,
                                        length: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_set_local_infile_handler(mysql: *mut MYSQL,
                                          local_infile_init:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *const ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             *mut ::std::os::raw::c_void)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          local_infile_read:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *mut ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             ::std::os::raw::c_uint)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          local_infile_end:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void)>,
                                          local_infile_error:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *mut ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             ::std::os::raw::c_uint)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mysql_set_local_infile_default(mysql: *mut MYSQL);
}
extern "C" {
    pub fn mysql_shutdown(mysql: *mut MYSQL,
                          shutdown_level: mysql_enum_shutdown_level)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_dump_debug_info(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_refresh(mysql: *mut MYSQL,
                         refresh_options: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_kill(mysql: *mut MYSQL, pid: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_set_server_option(mysql: *mut MYSQL,
                                   option: enum_mysql_set_option)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_ping(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stat(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_server_info(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_client_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_client_version() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_get_host_info(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_server_version(mysql: *mut MYSQL)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_get_proto_info(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_list_dbs(mysql: *mut MYSQL,
                          wild: *const ::std::os::raw::c_char)
     -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_list_tables(mysql: *mut MYSQL,
                             wild: *const ::std::os::raw::c_char)
     -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_list_processes(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_options(mysql: *mut MYSQL, option: mysql_option,
                         arg: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_options4(mysql: *mut MYSQL, option: mysql_option,
                          arg1: *const ::std::os::raw::c_void,
                          arg2: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_get_option(mysql: *mut MYSQL, option: mysql_option,
                            arg: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_free_result(result: *mut MYSQL_RES);
}
extern "C" {
    pub fn mysql_data_seek(result: *mut MYSQL_RES, offset: my_ulonglong);
}
extern "C" {
    pub fn mysql_row_seek(result: *mut MYSQL_RES, offset: MYSQL_ROW_OFFSET)
     -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_field_seek(result: *mut MYSQL_RES,
                            offset: MYSQL_FIELD_OFFSET) -> MYSQL_FIELD_OFFSET;
}
extern "C" {
    pub fn mysql_fetch_row(result: *mut MYSQL_RES) -> MYSQL_ROW;
}
extern "C" {
    pub fn mysql_fetch_lengths(result: *mut MYSQL_RES)
     -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_fetch_field(result: *mut MYSQL_RES) -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_list_fields(mysql: *mut MYSQL,
                             table: *const ::std::os::raw::c_char,
                             wild: *const ::std::os::raw::c_char)
     -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_escape_string(to: *mut ::std::os::raw::c_char,
                               from: *const ::std::os::raw::c_char,
                               from_length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_hex_string(to: *mut ::std::os::raw::c_char,
                            from: *const ::std::os::raw::c_char,
                            from_length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_real_escape_string(mysql: *mut MYSQL,
                                    to: *mut ::std::os::raw::c_char,
                                    from: *const ::std::os::raw::c_char,
                                    length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_real_escape_string_quote(mysql: *mut MYSQL,
                                          to: *mut ::std::os::raw::c_char,
                                          from: *const ::std::os::raw::c_char,
                                          length: ::std::os::raw::c_ulong,
                                          quote: ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_debug(debug: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn mysql_thread_safe() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_embedded() -> my_bool;
}
extern "C" {
    pub fn mysql_read_query_result(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_reset_connection(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_mysql_stmt_state {
    MYSQL_STMT_INIT_DONE = 1,
    MYSQL_STMT_PREPARE_DONE = 2,
    MYSQL_STMT_EXECUTE_DONE = 3,
    MYSQL_STMT_FETCH_DONE = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_bind {
    pub length: *mut ::std::os::raw::c_ulong,
    pub is_null: *mut my_bool,
    pub buffer: *mut ::std::os::raw::c_void,
    pub error: *mut my_bool,
    pub row_ptr: *mut ::std::os::raw::c_uchar,
    pub store_param_func: ::std::option::Option<unsafe extern "C" fn(net:
                                                                         *mut NET,
                                                                     param:
                                                                         *mut st_mysql_bind)>,
    pub fetch_result: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut st_mysql_bind,
                                                                 arg2:
                                                                     *mut MYSQL_FIELD,
                                                                 row:
                                                                     *mut *mut ::std::os::raw::c_uchar)>,
    pub skip_result: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut st_mysql_bind,
                                                                arg2:
                                                                    *mut MYSQL_FIELD,
                                                                row:
                                                                    *mut *mut ::std::os::raw::c_uchar)>,
    pub buffer_length: ::std::os::raw::c_ulong,
    pub offset: ::std::os::raw::c_ulong,
    pub length_value: ::std::os::raw::c_ulong,
    pub param_number: ::std::os::raw::c_uint,
    pub pack_length: ::std::os::raw::c_uint,
    pub buffer_type: enum_field_types,
    pub error_value: my_bool,
    pub is_unsigned: my_bool,
    pub long_data_used: my_bool,
    pub is_null_value: my_bool,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_bind() {
    assert_eq!(::std::mem::size_of::<st_mysql_bind>() , 104usize , concat ! (
               "Size of: " , stringify ! ( st_mysql_bind ) ));
    assert_eq! (::std::mem::align_of::<st_mysql_bind>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( st_mysql_bind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . is_null as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( is_null ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . buffer as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . error as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . row_ptr as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( row_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . store_param_func as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( store_param_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . fetch_result as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( fetch_result ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . skip_result as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( skip_result ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . buffer_length as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( buffer_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . offset as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . length_value as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( length_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . param_number as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( param_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . pack_length as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( pack_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . buffer_type as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( buffer_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . error_value as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( error_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . is_unsigned as *
                const _ as usize } , 89usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( is_unsigned ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . long_data_used as *
                const _ as usize } , 90usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( long_data_used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . is_null_value as *
                const _ as usize } , 91usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( is_null_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const st_mysql_bind ) ) . extension as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( st_mysql_bind ) , "::"
                , stringify ! ( extension ) ));
}
impl Clone for st_mysql_bind {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_BIND = st_mysql_bind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_stmt_extension {
    _unused: [u8; 0],
}
pub type MYSQL_STMT = st_mysql_stmt;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_stmt_attr_type {
    STMT_ATTR_UPDATE_MAX_LENGTH = 0,
    STMT_ATTR_CURSOR_TYPE = 1,
    STMT_ATTR_PREFETCH_ROWS = 2,
}
extern "C" {
    pub fn mysql_stmt_init(mysql: *mut MYSQL) -> *mut MYSQL_STMT;
}
extern "C" {
    pub fn mysql_stmt_prepare(stmt: *mut MYSQL_STMT,
                              query: *const ::std::os::raw::c_char,
                              length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_execute(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_fetch(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_fetch_column(stmt: *mut MYSQL_STMT,
                                   bind_arg: *mut MYSQL_BIND,
                                   column: ::std::os::raw::c_uint,
                                   offset: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_store_result(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_param_count(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_stmt_attr_set(stmt: *mut MYSQL_STMT,
                               attr_type: enum_stmt_attr_type,
                               attr: *const ::std::os::raw::c_void)
     -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_attr_get(stmt: *mut MYSQL_STMT,
                               attr_type: enum_stmt_attr_type,
                               attr: *mut ::std::os::raw::c_void) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_bind_param(stmt: *mut MYSQL_STMT, bnd: *mut MYSQL_BIND)
     -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_bind_result(stmt: *mut MYSQL_STMT, bnd: *mut MYSQL_BIND)
     -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_close(stmt: *mut MYSQL_STMT) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_reset(stmt: *mut MYSQL_STMT) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_free_result(stmt: *mut MYSQL_STMT) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_send_long_data(stmt: *mut MYSQL_STMT,
                                     param_number: ::std::os::raw::c_uint,
                                     data: *const ::std::os::raw::c_char,
                                     length: ::std::os::raw::c_ulong)
     -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_result_metadata(stmt: *mut MYSQL_STMT)
     -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_stmt_param_metadata(stmt: *mut MYSQL_STMT) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_stmt_errno(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_stmt_error(stmt: *mut MYSQL_STMT)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_stmt_sqlstate(stmt: *mut MYSQL_STMT)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_stmt_row_seek(stmt: *mut MYSQL_STMT,
                               offset: MYSQL_ROW_OFFSET) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_stmt_row_tell(stmt: *mut MYSQL_STMT) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_stmt_data_seek(stmt: *mut MYSQL_STMT, offset: my_ulonglong);
}
extern "C" {
    pub fn mysql_stmt_num_rows(stmt: *mut MYSQL_STMT) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_stmt_affected_rows(stmt: *mut MYSQL_STMT) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_stmt_insert_id(stmt: *mut MYSQL_STMT) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_stmt_field_count(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_commit(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_rollback(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_autocommit(mysql: *mut MYSQL, auto_mode: my_bool) -> my_bool;
}
extern "C" {
    pub fn mysql_more_results(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_next_result(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_next_result(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_close(sock: *mut MYSQL);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct charset_info_st {
    pub _address: u8,
}
impl Clone for charset_info_st {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_dynamic_array {
    pub _address: u8,
}
impl Clone for st_dynamic_array {
    fn clone(&self) -> Self { *self }
}
